/*
 * @lc app=leetcode id=928 lang=csharp
 *
 * [928] Minimize Malware Spread II
 */

using System.Collections.Generic;
using System.Linq;

// @lc code=start
public class Solution {
    private static int Spread(int[][] graph, int[] initial, int n, int removed) {
        var infected = new HashSet<int>(initial.Where(x => x != removed));
        var queue = new Queue<int>(infected);
        while (queue.Any()) {
            int curr = queue.Dequeue();
            foreach (int next in graph[curr]
                .Select((int v, int index) => (Connected: v == 1, Index: index))
                .Where(tuple => tuple.Connected && tuple.Index != removed && !infected.Contains(tuple.Index))
                .Select(tuple => tuple.Index)) {
                infected.Add(next);
                queue.Enqueue(next);
            }
        }
        return infected.Count;
    }

    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.Length, ret = 0, min = int.MaxValue;
        foreach (int num in initial) {
            int count = Spread(graph, initial, n, num);
            if (count < min || (count == min && num < ret)) {
                ret = num;
                min = count;
            }
        }
        return ret;
    }
}
// @lc code=end

